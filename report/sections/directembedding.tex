\section{Directembedding} % (fold)
\label{sec:Directembedding}
The architecture of the Directembedding library went through a major overhaul in this project.
The reification has been extended with new annotations and new capabilities such as language virtualization.
The reification is now highly customizable by the DSL author.
The library also aims to provide useful error messages where possible.

The following sections explain the improvements that have been made to the Directembedding library in this project.
For more details on how Directembedding works please consult the project's Github site\footnote{\href{https://github.com/directembedding/directembedding}{https://github.com/directembedding/directembedding}}.

\subsection{Architecture} % (fold)
\label{sub:Architecture}
Figure~\ref{fig:pipeline} shows the new architecture of Directembedding.
PreProcessing is an optional pass in the shallow embedding where the DSL author can transform the program in any way necessary before reification.
PreProcessing requires knowledge of the Scala reflection API.\
The DSLVirtualization pass performs the language virtualization explained in Section~\ref{sub:LanguageVirtualization}.
This pass happens in the shallow embedding.
ReificationTransformation is the major component of Directembedding and lifts the shallow embedding into the deep embedding.
In this pass, the attached metadata to the shallow embedding is used to reify the program into the DSL author's IR.\
PostProcessing is an optional pass through the deep embedding where the DSL author can transform the program in any way necessary before the program is passed back to the user.

% A valid DSL program must type-check in three stages of the pipeline: before PreProcessing, during DSLVirtualization and after PostProcessing.
% A well designed DSL should guarantee that a compilation error only occurs before PreProcessing or
% program compiles in the before 

The entry point to using Directembedding is now \texttt{DETransformer}.
The design of the DETransformer is inspired by the \texttt{YYTransformer} in Yin-Yang~\autocite{jovanovic_yin-yang:_2014}.
An example Directembedding DSL is provided the \texttt{example} package object.

\begin{figure}
    \centering
    \begin{tikzpicture}
        [node distance=.5cm,
        start chain=going below,]
        \node[punktchain, join] (preprocess)  {PreProcessing};
        \node[punktchain, join] (virt)        {DSLVirtualization};
        \node[punktchain, join] (embed)       {ReificationTransformation};
        \node[punktchain, join] (postprocess) {PostProcessing};
    \end{tikzpicture}
    \caption{The Directembedding transformation pipeline.}\label{fig:pipeline}
\end{figure}

% subsection Architecture (end)
\subsection{Language virtualization} % (fold)
\label{sub:LanguageVirtualization}
Language virtualization is the process of converting standard language features into method calls, in order to give them arbitrary semantics.
Such language features include if-then-else statements, loops, and variable assignments.
It is not possible to override the semantics of such statements in Scala without macros.

Directembedding uses the language virtualization provided by the Yin-Yang~\autocite{jovanovic_yin-yang:_2014} framework.
This transformation happens in the DSLVirtualization pass.
The DSL author is able to configure which language features to override through the \texttt{DslConfig} trait.
The \texttt{LanguageVirtualizationSpec} shows 43 examples of how to use the language virtualization feature in Directembedding.
% subsection Language virtualization (end)

\subsection{Overriding predefined and third-party types} % (fold)
\label{sub:Overridingpredefinedandthirdpartytypes}
Directembedding supports the ability to override the behavior of predefined and third-party types.
Predefined types are types provided by standard Scala libraries, such as \texttt{Int} and \texttt{String}.
Third-party types can be any types in a third-party library supported by the DSL.\

\begin{sloppypar}
    Reification for overriden types works the same way as reification with any other types.
    The \texttt{typeMap} argument to \texttt{DETransformer} tells Directembedding where to to look for reification annotations.
    If Directembedding does not find metadata to an invoked symbol, Directembedding will look for annotations on types in the \texttt{typeMap}.
    This search on types and finding matching symbols is currently implemented in a na√Øve way, and could be improved in future implementations.
    \texttt{TypeOverridingSpec} provides 6 examples of how to use the type overriding feature in Directembedding.
\end{sloppypar}

% subsection Overriding predefined and third-party types (end)

\subsection{Configurable reification} % (fold)
\label{sub:Configurablereification}

% subsection Configurable reification (end)

\subsection{Improved error messages} % (fold)
\label{sub:Improvederrormessages}

% subsection Improved error messages (end)

\begin{itemize}
    \item Explain \texttt{reifyAs} annotations, provide examples.
    \item Explain pipeline.
\end{itemize}


% section Directembedding (end)
